/* tslint:disable */
/* eslint-disable */
/**
 * RGB Lightning Node
 * This is the OpenAPI specification for the [RGB Lightning Node](https://github.com/RGB-Tools/rgb-lightning-node) APIs.
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
import { BackupRequest } from '../models';
import { ChangePasswordRequest } from '../models';
import { CheckIndexerUrlRequest } from '../models';
import { CheckIndexerUrlResponse } from '../models';
import { EmptyResponse } from '../models';
import { InitRequest } from '../models';
import { InitResponse } from '../models';
import { NetworkInfoResponse } from '../models';
import { NodeInfoResponse } from '../models';
import { RestoreRequest } from '../models';
import { SendOnionMessageRequest } from '../models';
import { SignMessageRequest } from '../models';
import { SignMessageResponse } from '../models';
import { UnlockRequest } from '../models';
/**
 * OtherApi - axios parameter creator
 * @export
 */
export const OtherApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a backup of the node's data
     * @summary Backup the node
     * @param {BackupRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    backupPost: async (
      body?: BackupRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/backup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Change the node's password
     * @summary Change the password
     * @param {ChangePasswordRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changepasswordPost: async (
      body?: ChangePasswordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/changepassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Check the given indexer URL is valid
     * @summary Check an indexer URL
     * @param {CheckIndexerUrlRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkindexerurlPost: async (
      body?: CheckIndexerUrlRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/checkindexerurl`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Initialize a new node
     * @summary Init the node
     * @param {InitRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initPost: async (
      body?: InitRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/init`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Lock an unlocked node
     * @summary Lock the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/lock`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get info on the Bitcoin network where the LN is running
     * @summary Get network info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    networkinfoGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/networkinfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the LN node's info
     * @summary Get node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nodeinfoGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/nodeinfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Restore a node from a backup file
     * @summary Restore the node
     * @param {RestoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restorePost: async (
      body?: RestoreRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/restore`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Send an onion message via the LN
     * @summary Send an onion message
     * @param {SendOnionMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendonionmessagePost: async (
      body?: SendOnionMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sendonionmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Gracefully shutdown the node
     * @summary Shutdown the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdownPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/shutdown`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Sign the provided message
     * @summary Sign a message
     * @param {SignMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signmessagePost: async (
      body?: SignMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/signmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Unlock a locked node
     * @summary Unlock the node
     * @param {UnlockRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlockPost: async (
      body?: UnlockRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/unlock`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OtherApi - functional programming interface
 * @export
 */
export const OtherApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a backup of the node's data
     * @summary Backup the node
     * @param {BackupRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async backupPost(
      body?: BackupRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).backupPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the node's password
     * @summary Change the password
     * @param {ChangePasswordRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changepasswordPost(
      body?: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).changepasswordPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Check the given indexer URL is valid
     * @summary Check an indexer URL
     * @param {CheckIndexerUrlRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkindexerurlPost(
      body?: CheckIndexerUrlRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<CheckIndexerUrlResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).checkindexerurlPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Initialize a new node
     * @summary Init the node
     * @param {InitRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initPost(
      body?: InitRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<InitResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).initPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Lock an unlocked node
     * @summary Lock the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lockPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).lockPost(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get info on the Bitcoin network where the LN is running
     * @summary Get network info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async networkinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<NetworkInfoResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).networkinfoGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the LN node's info
     * @summary Get node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nodeinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<NodeInfoResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).nodeinfoGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Restore a node from a backup file
     * @summary Restore the node
     * @param {RestoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restorePost(
      body?: RestoreRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).restorePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send an onion message via the LN
     * @summary Send an onion message
     * @param {SendOnionMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendonionmessagePost(
      body?: SendOnionMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).sendonionmessagePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Gracefully shutdown the node
     * @summary Shutdown the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async shutdownPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).shutdownPost(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Sign the provided message
     * @summary Sign a message
     * @param {SignMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signmessagePost(
      body?: SignMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<SignMessageResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).signmessagePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Unlock a locked node
     * @summary Unlock the node
     * @param {UnlockRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlockPost(
      body?: UnlockRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await OtherApiAxiosParamCreator(
        configuration,
      ).unlockPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * OtherApi - factory interface
 * @export
 */
export const OtherApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Create a backup of the node's data
     * @summary Backup the node
     * @param {BackupRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async backupPost(
      body?: BackupRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .backupPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Change the node's password
     * @summary Change the password
     * @param {ChangePasswordRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changepasswordPost(
      body?: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .changepasswordPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Check the given indexer URL is valid
     * @summary Check an indexer URL
     * @param {CheckIndexerUrlRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkindexerurlPost(
      body?: CheckIndexerUrlRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<CheckIndexerUrlResponse>> {
      return OtherApiFp(configuration)
        .checkindexerurlPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Initialize a new node
     * @summary Init the node
     * @param {InitRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initPost(
      body?: InitRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InitResponse>> {
      return OtherApiFp(configuration)
        .initPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Lock an unlocked node
     * @summary Lock the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lockPost(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .lockPost(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get info on the Bitcoin network where the LN is running
     * @summary Get network info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async networkinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<NetworkInfoResponse>> {
      return OtherApiFp(configuration)
        .networkinfoGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get the LN node's info
     * @summary Get node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nodeinfoGet(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<NodeInfoResponse>> {
      return OtherApiFp(configuration)
        .nodeinfoGet(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Restore a node from a backup file
     * @summary Restore the node
     * @param {RestoreRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restorePost(
      body?: RestoreRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .restorePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Send an onion message via the LN
     * @summary Send an onion message
     * @param {SendOnionMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendonionmessagePost(
      body?: SendOnionMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .sendonionmessagePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Gracefully shutdown the node
     * @summary Shutdown the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async shutdownPost(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .shutdownPost(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Sign the provided message
     * @summary Sign a message
     * @param {SignMessageRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signmessagePost(
      body?: SignMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<SignMessageResponse>> {
      return OtherApiFp(configuration)
        .signmessagePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Unlock a locked node
     * @summary Unlock the node
     * @param {UnlockRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlockPost(
      body?: UnlockRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return OtherApiFp(configuration)
        .unlockPost(body, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * OtherApi - object-oriented interface
 * @export
 * @class OtherApi
 * @extends {BaseAPI}
 */
export class OtherApi extends BaseAPI {
  /**
   * Create a backup of the node's data
   * @summary Backup the node
   * @param {BackupRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async backupPost(
    body?: BackupRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .backupPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Change the node's password
   * @summary Change the password
   * @param {ChangePasswordRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async changepasswordPost(
    body?: ChangePasswordRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .changepasswordPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Check the given indexer URL is valid
   * @summary Check an indexer URL
   * @param {CheckIndexerUrlRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async checkindexerurlPost(
    body?: CheckIndexerUrlRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<CheckIndexerUrlResponse>> {
    return OtherApiFp(this.configuration)
      .checkindexerurlPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Initialize a new node
   * @summary Init the node
   * @param {InitRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async initPost(
    body?: InitRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InitResponse>> {
    return OtherApiFp(this.configuration)
      .initPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Lock an unlocked node
   * @summary Lock the node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async lockPost(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .lockPost(options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Get info on the Bitcoin network where the LN is running
   * @summary Get network info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async networkinfoGet(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<NetworkInfoResponse>> {
    return OtherApiFp(this.configuration)
      .networkinfoGet(options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Get the LN node's info
   * @summary Get node info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async nodeinfoGet(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<NodeInfoResponse>> {
    return OtherApiFp(this.configuration)
      .nodeinfoGet(options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Restore a node from a backup file
   * @summary Restore the node
   * @param {RestoreRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async restorePost(
    body?: RestoreRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .restorePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Send an onion message via the LN
   * @summary Send an onion message
   * @param {SendOnionMessageRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async sendonionmessagePost(
    body?: SendOnionMessageRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .sendonionmessagePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Gracefully shutdown the node
   * @summary Shutdown the node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async shutdownPost(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .shutdownPost(options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Sign the provided message
   * @summary Sign a message
   * @param {SignMessageRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async signmessagePost(
    body?: SignMessageRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<SignMessageResponse>> {
    return OtherApiFp(this.configuration)
      .signmessagePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Unlock a locked node
   * @summary Unlock the node
   * @param {UnlockRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtherApi
   */
  public async unlockPost(
    body?: UnlockRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return OtherApiFp(this.configuration)
      .unlockPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
}
