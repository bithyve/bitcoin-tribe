/* tslint:disable */
/* eslint-disable */
/**
 * RGB Lightning Node
 * This is the OpenAPI specification for the [RGB Lightning Node](https://github.com/RGB-Tools/rgb-lightning-node) APIs.
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
import { AssetBalanceRequest } from '../models';
import { AssetBalanceResponse } from '../models';
import { CreateUtxosRequest } from '../models';
import { DecodeRGBInvoiceRequest } from '../models';
import { DecodeRGBInvoiceResponse } from '../models';
import { EmptyResponse } from '../models';
import { FailTransfersRequest } from '../models';
import { FailTransfersResponse } from '../models';
import { GetAssetMediaRequest } from '../models';
import { GetAssetMediaResponse } from '../models';
import { IssueAssetCFARequest } from '../models';
import { IssueAssetCFAResponse } from '../models';
import { IssueAssetNIARequest } from '../models';
import { IssueAssetNIAResponse } from '../models';
import { IssueAssetUDARequest } from '../models';
import { IssueAssetUDAResponse } from '../models';
import { ListAssetsRequest } from '../models';
import { ListAssetsResponse } from '../models';
import { ListTransfersRequest } from '../models';
import { ListTransfersResponse } from '../models';
import { PostAssetMediaResponse } from '../models';
import { RgbInvoiceRequest } from '../models';
import { RgbInvoiceResponse } from '../models';
import { SendAssetRequest } from '../models';
import { SendAssetResponse } from '../models';
/**
 * RGBApi - axios parameter creator
 * @export
 */
export const RGBApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the balance for the provided RGB asset
     * @summary Get the balance of an asset
     * @param {AssetBalanceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assetbalancePost: async (
      body?: AssetBalanceRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/assetbalance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Create UTXOs to be used for RGB operations
     * @summary Create UTXOs
     * @param {CreateUtxosRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createutxosPost: async (
      body?: CreateUtxosRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/createutxos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Decode the provided RGB invoice string
     * @summary Decode an RGB invoice
     * @param {DecodeRGBInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decodergbinvoicePost: async (
      body?: DecodeRGBInvoiceRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/decodergbinvoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Set the status for eligible RGB transfers to `TransferStatus::Failed`.
     * @summary Fail RGB transfers
     * @param {FailTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    failtransfersPost: async (
      body?: FailTransfersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/failtransfers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the hex string of the media bytes of the provided media digest
     * @summary Get an asset media
     * @param {GetAssetMediaRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getassetmediaPost: async (
      body?: GetAssetMediaRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/getassetmedia`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Issue an RGB CFA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB CFA asset
     * @param {IssueAssetCFARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueassetcfaPost: async (
      body?: IssueAssetCFARequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/issueassetcfa`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Issue an RGB NIA asset
     * @summary Issue an RGB NIA asset
     * @param {IssueAssetNIARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueassetniaPost: async (
      body?: IssueAssetNIARequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/issueassetnia`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Issue an RGB UDA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB UDA asset
     * @param {IssueAssetUDARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueassetudaPost: async (
      body?: IssueAssetUDARequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/issueassetuda`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * List the node's RGB assets
     * @summary List assets
     * @param {ListAssetsRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listassetsPost: async (
      body?: ListAssetsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listassets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * List the node's on-chain RGB transfers
     * @summary List transfers
     * @param {ListTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listtransfersPost: async (
      body?: ListTransfersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listtransfers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Save the provided media
     * @summary Post an asset media
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postassetmediaPostForm: async (
      file?: Blob,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/postassetmedia`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh RGB pending transfers
     * @summary Refresh transfers
     * @param {boolean} [skipSync]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshtransfersPostForm: async (
      skipSync?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/refreshtransfers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      if (skipSync !== undefined) {
        localVarFormParams.append('skip_sync', skipSync as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an RGB invoice to receive assets on-chain
     * @summary Get an RGB invoice
     * @param {RgbInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rgbinvoicePost: async (
      body?: RgbInvoiceRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/rgbinvoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Send RGB assets on-chain
     * @summary Send assets
     * @param {SendAssetRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendassetPost: async (
      body?: SendAssetRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sendasset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Sync the RGB wallet
     * @summary Sync the RGB wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncPost: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sync`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] = accessToken;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RGBApi - functional programming interface
 * @export
 */
export const RGBApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Get the balance for the provided RGB asset
     * @summary Get the balance of an asset
     * @param {AssetBalanceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assetbalancePost(
      body?: AssetBalanceRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<AssetBalanceResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).assetbalancePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Create UTXOs to be used for RGB operations
     * @summary Create UTXOs
     * @param {CreateUtxosRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createutxosPost(
      body?: CreateUtxosRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).createutxosPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Decode the provided RGB invoice string
     * @summary Decode an RGB invoice
     * @param {DecodeRGBInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decodergbinvoicePost(
      body?: DecodeRGBInvoiceRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<DecodeRGBInvoiceResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).decodergbinvoicePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Set the status for eligible RGB transfers to `TransferStatus::Failed`.
     * @summary Fail RGB transfers
     * @param {FailTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async failtransfersPost(
      body?: FailTransfersRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<FailTransfersResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).failtransfersPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the hex string of the media bytes of the provided media digest
     * @summary Get an asset media
     * @param {GetAssetMediaRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getassetmediaPost(
      body?: GetAssetMediaRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<GetAssetMediaResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).getassetmediaPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Issue an RGB CFA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB CFA asset
     * @param {IssueAssetCFARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetcfaPost(
      body?: IssueAssetCFARequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<IssueAssetCFAResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).issueassetcfaPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Issue an RGB NIA asset
     * @summary Issue an RGB NIA asset
     * @param {IssueAssetNIARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetniaPost(
      body?: IssueAssetNIARequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<IssueAssetNIAResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).issueassetniaPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
          validateStatus: () => false,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Issue an RGB UDA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB UDA asset
     * @param {IssueAssetUDARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetudaPost(
      body?: IssueAssetUDARequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<IssueAssetUDAResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).issueassetudaPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * List the node's RGB assets
     * @summary List assets
     * @param {ListAssetsRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listassetsPost(
      body?: ListAssetsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<ListAssetsResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).listassetsPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * List the node's on-chain RGB transfers
     * @summary List transfers
     * @param {ListTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listtransfersPost(
      body?: ListTransfersRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<ListTransfersResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).listtransfersPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Save the provided media
     * @summary Post an asset media
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postassetmediaPostForm(
      file?: Blob,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<PostAssetMediaResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).postassetmediaPostForm(file, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Refresh RGB pending transfers
     * @summary Refresh transfers
     * @param {boolean} [skipSync]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshtransfersPostForm(
      skipSync?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).refreshtransfersPostForm(skipSync, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get an RGB invoice to receive assets on-chain
     * @summary Get an RGB invoice
     * @param {RgbInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rgbinvoicePost(
      body?: RgbInvoiceRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<RgbInvoiceResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).rgbinvoicePost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Send RGB assets on-chain
     * @summary Send assets
     * @param {SendAssetRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendassetPost(
      body?: SendAssetRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<SendAssetResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).sendassetPost(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Sync the RGB wallet
     * @summary Sync the RGB wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async syncPost(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<EmptyResponse>>
    > {
      const localVarAxiosArgs = await RGBApiAxiosParamCreator(
        configuration,
      ).syncPost(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * RGBApi - factory interface
 * @export
 */
export const RGBApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Get the balance for the provided RGB asset
     * @summary Get the balance of an asset
     * @param {AssetBalanceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assetbalancePost(
      body?: AssetBalanceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<AssetBalanceResponse>> {
      return RGBApiFp(configuration)
        .assetbalancePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Create UTXOs to be used for RGB operations
     * @summary Create UTXOs
     * @param {CreateUtxosRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createutxosPost(
      body?: CreateUtxosRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return RGBApiFp(configuration)
        .createutxosPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Decode the provided RGB invoice string
     * @summary Decode an RGB invoice
     * @param {DecodeRGBInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decodergbinvoicePost(
      body?: DecodeRGBInvoiceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<DecodeRGBInvoiceResponse>> {
      return RGBApiFp(configuration)
        .decodergbinvoicePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Set the status for eligible RGB transfers to `TransferStatus::Failed`.
     * @summary Fail RGB transfers
     * @param {FailTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async failtransfersPost(
      body?: FailTransfersRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FailTransfersResponse>> {
      return RGBApiFp(configuration)
        .failtransfersPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get the hex string of the media bytes of the provided media digest
     * @summary Get an asset media
     * @param {GetAssetMediaRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getassetmediaPost(
      body?: GetAssetMediaRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<GetAssetMediaResponse>> {
      return RGBApiFp(configuration)
        .getassetmediaPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Issue an RGB CFA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB CFA asset
     * @param {IssueAssetCFARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetcfaPost(
      body?: IssueAssetCFARequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<IssueAssetCFAResponse>> {
      return RGBApiFp(configuration)
        .issueassetcfaPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Issue an RGB NIA asset
     * @summary Issue an RGB NIA asset
     * @param {IssueAssetNIARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetniaPost(
      body?: IssueAssetNIARequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<IssueAssetNIAResponse>> {
      return RGBApiFp(configuration)
        .issueassetniaPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Issue an RGB UDA asset. To provide a media first call the /postassetmedia API.
     * @summary Issue an RGB UDA asset
     * @param {IssueAssetUDARequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issueassetudaPost(
      body?: IssueAssetUDARequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<IssueAssetUDAResponse>> {
      return RGBApiFp(configuration)
        .issueassetudaPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List the node's RGB assets
     * @summary List assets
     * @param {ListAssetsRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listassetsPost(
      body?: ListAssetsRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<ListAssetsResponse>> {
      return RGBApiFp(configuration)
        .listassetsPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * List the node's on-chain RGB transfers
     * @summary List transfers
     * @param {ListTransfersRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listtransfersPost(
      body?: ListTransfersRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<ListTransfersResponse>> {
      return RGBApiFp(configuration)
        .listtransfersPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Save the provided media
     * @summary Post an asset media
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postassetmediaPostForm(
      file?: Blob,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PostAssetMediaResponse>> {
      return RGBApiFp(configuration)
        .postassetmediaPostForm(file, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Refresh RGB pending transfers
     * @summary Refresh transfers
     * @param {boolean} [skipSync]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshtransfersPostForm(
      skipSync?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return RGBApiFp(configuration)
        .refreshtransfersPostForm(skipSync, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get an RGB invoice to receive assets on-chain
     * @summary Get an RGB invoice
     * @param {RgbInvoiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rgbinvoicePost(
      body?: RgbInvoiceRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<RgbInvoiceResponse>> {
      return RGBApiFp(configuration)
        .rgbinvoicePost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Send RGB assets on-chain
     * @summary Send assets
     * @param {SendAssetRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendassetPost(
      body?: SendAssetRequest,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<SendAssetResponse>> {
      return RGBApiFp(configuration)
        .sendassetPost(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Sync the RGB wallet
     * @summary Sync the RGB wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async syncPost(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<EmptyResponse>> {
      return RGBApiFp(configuration)
        .syncPost(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * RGBApi - object-oriented interface
 * @export
 * @class RGBApi
 * @extends {BaseAPI}
 */
export class RGBApi extends BaseAPI {
  /**
   * Get the balance for the provided RGB asset
   * @summary Get the balance of an asset
   * @param {AssetBalanceRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async assetbalancePost(
    body?: AssetBalanceRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<AssetBalanceResponse>> {
    return RGBApiFp(this.configuration)
      .assetbalancePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Create UTXOs to be used for RGB operations
   * @summary Create UTXOs
   * @param {CreateUtxosRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async createutxosPost(
    body?: CreateUtxosRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return RGBApiFp(this.configuration)
      .createutxosPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Decode the provided RGB invoice string
   * @summary Decode an RGB invoice
   * @param {DecodeRGBInvoiceRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async decodergbinvoicePost(
    body?: DecodeRGBInvoiceRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<DecodeRGBInvoiceResponse>> {
    return RGBApiFp(this.configuration)
      .decodergbinvoicePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Set the status for eligible RGB transfers to `TransferStatus::Failed`.
   * @summary Fail RGB transfers
   * @param {FailTransfersRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async failtransfersPost(
    body?: FailTransfersRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<FailTransfersResponse>> {
    return RGBApiFp(this.configuration)
      .failtransfersPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Get the hex string of the media bytes of the provided media digest
   * @summary Get an asset media
   * @param {GetAssetMediaRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async getassetmediaPost(
    body?: GetAssetMediaRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<GetAssetMediaResponse>> {
    return RGBApiFp(this.configuration)
      .getassetmediaPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Issue an RGB CFA asset. To provide a media first call the /postassetmedia API.
   * @summary Issue an RGB CFA asset
   * @param {IssueAssetCFARequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async issueassetcfaPost(
    body?: IssueAssetCFARequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<IssueAssetCFAResponse>> {
    return RGBApiFp(this.configuration)
      .issueassetcfaPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Issue an RGB NIA asset
   * @summary Issue an RGB NIA asset
   * @param {IssueAssetNIARequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async issueassetniaPost(
    body?: IssueAssetNIARequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<IssueAssetNIAResponse>> {
    return RGBApiFp(this.configuration)
      .issueassetniaPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Issue an RGB UDA asset. To provide a media first call the /postassetmedia API.
   * @summary Issue an RGB UDA asset
   * @param {IssueAssetUDARequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async issueassetudaPost(
    body?: IssueAssetUDARequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<IssueAssetUDAResponse>> {
    return RGBApiFp(this.configuration)
      .issueassetudaPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * List the node's RGB assets
   * @summary List assets
   * @param {ListAssetsRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async listassetsPost(
    body?: ListAssetsRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<ListAssetsResponse>> {
    console.log('body', body);
    return RGBApiFp(this.configuration)
      .listassetsPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * List the node's on-chain RGB transfers
   * @summary List transfers
   * @param {ListTransfersRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async listtransfersPost(
    body?: ListTransfersRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<ListTransfersResponse>> {
    return RGBApiFp(this.configuration)
      .listtransfersPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Save the provided media
   * @summary Post an asset media
   * @param {Blob} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async postassetmediaPostForm(
    file?: Blob,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PostAssetMediaResponse>> {
    return RGBApiFp(this.configuration)
      .postassetmediaPostForm(file, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Refresh RGB pending transfers
   * @summary Refresh transfers
   * @param {boolean} [skipSync]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async refreshtransfersPostForm(
    skipSync?: boolean,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return RGBApiFp(this.configuration)
      .refreshtransfersPostForm(skipSync, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Get an RGB invoice to receive assets on-chain
   * @summary Get an RGB invoice
   * @param {RgbInvoiceRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async rgbinvoicePost(
    body?: RgbInvoiceRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<RgbInvoiceResponse>> {
    return RGBApiFp(this.configuration)
      .rgbinvoicePost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Send RGB assets on-chain
   * @summary Send assets
   * @param {SendAssetRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async sendassetPost(
    body?: SendAssetRequest,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<SendAssetResponse>> {
    return RGBApiFp(this.configuration)
      .sendassetPost(body, options)
      .then(request => request(this.axios, this.basePath));
  }
  /**
   * Sync the RGB wallet
   * @summary Sync the RGB wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RGBApi
   */
  public async syncPost(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<EmptyResponse>> {
    return RGBApiFp(this.configuration)
      .syncPost(options)
      .then(request => request(this.axios, this.basePath));
  }
}
